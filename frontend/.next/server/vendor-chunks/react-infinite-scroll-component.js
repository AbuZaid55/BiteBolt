"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-infinite-scroll-component";
exports.ids = ["vendor-chunks/react-infinite-scroll-component"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-infinite-scroll-component/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */ /**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */ function throttle(delay, noTrailing, callback, debounceMode) {\n    /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */ var timeoutID;\n    var cancelled = false; // Keep track of the last time `callback` was executed.\n    var lastExec = 0; // Function to clear existing timeout\n    function clearExistingTimeout() {\n        if (timeoutID) {\n            clearTimeout(timeoutID);\n        }\n    } // Function to cancel next exec\n    function cancel() {\n        clearExistingTimeout();\n        cancelled = true;\n    } // `noTrailing` defaults to falsy.\n    if (typeof noTrailing !== \"boolean\") {\n        debounceMode = callback;\n        callback = noTrailing;\n        noTrailing = undefined;\n    }\n    /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */ function wrapper() {\n        var self = this;\n        var elapsed = Date.now() - lastExec;\n        var args = arguments;\n        if (cancelled) {\n            return;\n        } // Execute `callback` and update the `lastExec` timestamp.\n        function exec() {\n            lastExec = Date.now();\n            callback.apply(self, args);\n        }\n        /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */ function clear() {\n            timeoutID = undefined;\n        }\n        if (debounceMode && !timeoutID) {\n            /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */ exec();\n        }\n        clearExistingTimeout();\n        if (debounceMode === undefined && elapsed > delay) {\n            /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */ exec();\n        } else if (noTrailing !== true) {\n            /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */ timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n        }\n    }\n    wrapper.cancel = cancel; // Return the wrapper function.\n    return wrapper;\n}\nvar ThresholdUnits = {\n    Pixel: \"Pixel\",\n    Percent: \"Percent\"\n};\nvar defaultThreshold = {\n    unit: ThresholdUnits.Percent,\n    value: 0.8\n};\nfunction parseThreshold(scrollThreshold) {\n    if (typeof scrollThreshold === \"number\") {\n        return {\n            unit: ThresholdUnits.Percent,\n            value: scrollThreshold * 100\n        };\n    }\n    if (typeof scrollThreshold === \"string\") {\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)px$/)) {\n            return {\n                unit: ThresholdUnits.Pixel,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)%$/)) {\n            return {\n                unit: ThresholdUnits.Percent,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        console.warn('scrollThreshold format is invalid. Valid formats: \"120px\", \"50%\"...');\n        return defaultThreshold;\n    }\n    console.warn(\"scrollThreshold should be string or number\");\n    return defaultThreshold;\n}\nvar InfiniteScroll = /** @class */ function(_super) {\n    __extends(InfiniteScroll, _super);\n    function InfiniteScroll(props) {\n        var _this = _super.call(this, props) || this;\n        _this.lastScrollTop = 0;\n        _this.actionTriggered = false;\n        // variables to keep track of pull down behaviour\n        _this.startY = 0;\n        _this.currentY = 0;\n        _this.dragging = false;\n        // will be populated in componentDidMount\n        // based on the height of the pull down element\n        _this.maxPullDownDistance = 0;\n        _this.getScrollableTarget = function() {\n            if (_this.props.scrollableTarget instanceof HTMLElement) return _this.props.scrollableTarget;\n            if (typeof _this.props.scrollableTarget === \"string\") {\n                return document.getElementById(_this.props.scrollableTarget);\n            }\n            if (_this.props.scrollableTarget === null) {\n                console.warn(\"You are trying to pass scrollableTarget but it is null. This might\\n        happen because the element may not have been added to DOM yet.\\n        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.\\n      \");\n            }\n            return null;\n        };\n        _this.onStart = function(evt) {\n            if (_this.lastScrollTop) return;\n            _this.dragging = true;\n            if (evt instanceof MouseEvent) {\n                _this.startY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.startY = evt.touches[0].pageY;\n            }\n            _this.currentY = _this.startY;\n            if (_this._infScroll) {\n                _this._infScroll.style.willChange = \"transform\";\n                _this._infScroll.style.transition = \"transform 0.2s cubic-bezier(0,0,0.31,1)\";\n            }\n        };\n        _this.onMove = function(evt) {\n            if (!_this.dragging) return;\n            if (evt instanceof MouseEvent) {\n                _this.currentY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.currentY = evt.touches[0].pageY;\n            }\n            // user is scrolling down to up\n            if (_this.currentY < _this.startY) return;\n            if (_this.currentY - _this.startY >= Number(_this.props.pullDownToRefreshThreshold)) {\n                _this.setState({\n                    pullToRefreshThresholdBreached: true\n                });\n            }\n            // so you can drag upto 1.5 times of the maxPullDownDistance\n            if (_this.currentY - _this.startY > _this.maxPullDownDistance * 1.5) return;\n            if (_this._infScroll) {\n                _this._infScroll.style.overflow = \"visible\";\n                _this._infScroll.style.transform = \"translate3d(0px, \" + (_this.currentY - _this.startY) + \"px, 0px)\";\n            }\n        };\n        _this.onEnd = function() {\n            _this.startY = 0;\n            _this.currentY = 0;\n            _this.dragging = false;\n            if (_this.state.pullToRefreshThresholdBreached) {\n                _this.props.refreshFunction && _this.props.refreshFunction();\n                _this.setState({\n                    pullToRefreshThresholdBreached: false\n                });\n            }\n            requestAnimationFrame(function() {\n                // this._infScroll\n                if (_this._infScroll) {\n                    _this._infScroll.style.overflow = \"auto\";\n                    _this._infScroll.style.transform = \"none\";\n                    _this._infScroll.style.willChange = \"unset\";\n                }\n            });\n        };\n        _this.onScrollListener = function(event) {\n            if (typeof _this.props.onScroll === \"function\") {\n                // Execute this callback in next tick so that it does not affect the\n                // functionality of the library.\n                setTimeout(function() {\n                    return _this.props.onScroll && _this.props.onScroll(event);\n                }, 0);\n            }\n            var target = _this.props.height || _this._scrollableNode ? event.target : document.documentElement.scrollTop ? document.documentElement : document.body;\n            // return immediately if the action has already been triggered,\n            // prevents multiple triggers.\n            if (_this.actionTriggered) return;\n            var atBottom = _this.props.inverse ? _this.isElementAtTop(target, _this.props.scrollThreshold) : _this.isElementAtBottom(target, _this.props.scrollThreshold);\n            // call the `next` function in the props to trigger the next data fetch\n            if (atBottom && _this.props.hasMore) {\n                _this.actionTriggered = true;\n                _this.setState({\n                    showLoader: true\n                });\n                _this.props.next && _this.props.next();\n            }\n            _this.lastScrollTop = target.scrollTop;\n        };\n        _this.state = {\n            showLoader: false,\n            pullToRefreshThresholdBreached: false,\n            prevDataLength: props.dataLength\n        };\n        _this.throttledOnScrollListener = throttle(150, _this.onScrollListener).bind(_this);\n        _this.onStart = _this.onStart.bind(_this);\n        _this.onMove = _this.onMove.bind(_this);\n        _this.onEnd = _this.onEnd.bind(_this);\n        return _this;\n    }\n    InfiniteScroll.prototype.componentDidMount = function() {\n        if (typeof this.props.dataLength === \"undefined\") {\n            throw new Error('mandatory prop \"dataLength\" is missing. The prop is needed' + \" when loading more content. Check README.md for usage\");\n        }\n        this._scrollableNode = this.getScrollableTarget();\n        this.el = this.props.height ? this._infScroll : this._scrollableNode || window;\n        if (this.el) {\n            this.el.addEventListener(\"scroll\", this.throttledOnScrollListener);\n        }\n        if (typeof this.props.initialScrollY === \"number\" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY) {\n            this.el.scrollTo(0, this.props.initialScrollY);\n        }\n        if (this.props.pullDownToRefresh && this.el) {\n            this.el.addEventListener(\"touchstart\", this.onStart);\n            this.el.addEventListener(\"touchmove\", this.onMove);\n            this.el.addEventListener(\"touchend\", this.onEnd);\n            this.el.addEventListener(\"mousedown\", this.onStart);\n            this.el.addEventListener(\"mousemove\", this.onMove);\n            this.el.addEventListener(\"mouseup\", this.onEnd);\n            // get BCR of pullDown element to position it above\n            this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0;\n            this.forceUpdate();\n            if (typeof this.props.refreshFunction !== \"function\") {\n                throw new Error('Mandatory prop \"refreshFunction\" missing.\\n          Pull Down To Refresh functionality will not work\\n          as expected. Check README.md for usage\\'');\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentWillUnmount = function() {\n        if (this.el) {\n            this.el.removeEventListener(\"scroll\", this.throttledOnScrollListener);\n            if (this.props.pullDownToRefresh) {\n                this.el.removeEventListener(\"touchstart\", this.onStart);\n                this.el.removeEventListener(\"touchmove\", this.onMove);\n                this.el.removeEventListener(\"touchend\", this.onEnd);\n                this.el.removeEventListener(\"mousedown\", this.onStart);\n                this.el.removeEventListener(\"mousemove\", this.onMove);\n                this.el.removeEventListener(\"mouseup\", this.onEnd);\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentDidUpdate = function(prevProps) {\n        // do nothing when dataLength is unchanged\n        if (this.props.dataLength === prevProps.dataLength) return;\n        this.actionTriggered = false;\n        // update state when new data was sent in\n        this.setState({\n            showLoader: false\n        });\n    };\n    InfiniteScroll.getDerivedStateFromProps = function(nextProps, prevState) {\n        var dataLengthChanged = nextProps.dataLength !== prevState.prevDataLength;\n        // reset when data changes\n        if (dataLengthChanged) {\n            return __assign(__assign({}, prevState), {\n                prevDataLength: nextProps.dataLength\n            });\n        }\n        return null;\n    };\n    InfiniteScroll.prototype.isElementAtTop = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop <= threshold.value + clientHeight - target.scrollHeight + 1;\n        }\n        return target.scrollTop <= threshold.value / 100 + clientHeight - target.scrollHeight + 1;\n    };\n    InfiniteScroll.prototype.isElementAtBottom = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop + clientHeight >= target.scrollHeight - threshold.value;\n        }\n        return target.scrollTop + clientHeight >= threshold.value / 100 * target.scrollHeight;\n    };\n    InfiniteScroll.prototype.render = function() {\n        var _this = this;\n        var style = __assign({\n            height: this.props.height || \"auto\",\n            overflow: \"auto\",\n            WebkitOverflowScrolling: \"touch\"\n        }, this.props.style);\n        var hasChildren = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length);\n        // because heighted infiniteScroll visualy breaks\n        // on drag down as overflow becomes visible\n        var outerDivStyle = this.props.pullDownToRefresh && this.props.height ? {\n            overflow: \"auto\"\n        } : {};\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: outerDivStyle,\n            className: \"infinite-scroll-component__outerdiv\"\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"infinite-scroll-component \" + (this.props.className || \"\"),\n            ref: function(infScroll) {\n                return _this._infScroll = infScroll;\n            },\n            style: style\n        }, this.props.pullDownToRefresh && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"relative\"\n            },\n            ref: function(pullDown) {\n                return _this._pullDown = pullDown;\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"absolute\",\n                left: 0,\n                right: 0,\n                top: -1 * this.maxPullDownDistance\n            }\n        }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)), this.props.children, !this.state.showLoader && !hasChildren && this.props.hasMore && this.props.loader, this.state.showLoader && this.props.hasMore && this.props.loader, !this.props.hasMore && this.props.endMessage));\n    };\n    return InfiniteScroll;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InfiniteScroll); //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudC9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUV6Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsMkJBQTJCLEdBRTNCLElBQUlFLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlBLEVBQUVNLGNBQWMsQ0FBQ0QsSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQzdFLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU08sVUFBVVIsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CRixjQUFjQyxHQUFHQztJQUNqQixTQUFTUTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHVjtJQUFHO0lBQ3RDQSxFQUFFVyxTQUFTLEdBQUdWLE1BQU0sT0FBT0MsT0FBT1UsTUFBTSxDQUFDWCxLQUFNUSxDQUFBQSxHQUFHRSxTQUFTLEdBQUdWLEVBQUVVLFNBQVMsRUFBRSxJQUFJRixJQUFHO0FBQ3RGO0FBRUEsSUFBSUksV0FBVztJQUNYQSxXQUFXWCxPQUFPWSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJWCxLQUFLVSxFQUFHLElBQUlkLE9BQU9TLFNBQVMsQ0FBQ0osY0FBYyxDQUFD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RixLQUFLLFNBQVVHLFFBQVE7Z0JBQUksT0FBUXhGLE1BQU04RCxTQUFTLEdBQUcwQjtZQUFXO1FBQUUsaUJBQzdKdEosMERBQW1CLENBQUMsT0FBTztZQUFFaUYsT0FBTztnQkFDNUJvRSxVQUFVO2dCQUNWRSxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNyRixtQkFBbUI7WUFDdEM7UUFBRSxHQUFHLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ0osOEJBQThCLEdBQzVDLElBQUksQ0FBQzNCLEtBQUssQ0FBQzZGLHVCQUF1QixHQUNsQyxJQUFJLENBQUM3RixLQUFLLENBQUM4Rix3QkFBd0IsSUFDN0MsSUFBSSxDQUFDOUYsS0FBSyxDQUFDa0YsUUFBUSxFQUNuQixDQUFDLElBQUksQ0FBQ25ELEtBQUssQ0FBQ2lCLFVBQVUsSUFDbEIsQ0FBQ2lDLGVBQ0QsSUFBSSxDQUFDakYsS0FBSyxDQUFDK0MsT0FBTyxJQUNsQixJQUFJLENBQUMvQyxLQUFLLENBQUMrRixNQUFNLEVBQ3JCLElBQUksQ0FBQ2hFLEtBQUssQ0FBQ2lCLFVBQVUsSUFBSSxJQUFJLENBQUNoRCxLQUFLLENBQUMrQyxPQUFPLElBQUksSUFBSSxDQUFDL0MsS0FBSyxDQUFDK0YsTUFBTSxFQUNoRSxDQUFDLElBQUksQ0FBQy9GLEtBQUssQ0FBQytDLE9BQU8sSUFBSSxJQUFJLENBQUMvQyxLQUFLLENBQUNnRyxVQUFVO0lBQ3hEO0lBQ0EsT0FBT2xHO0FBQ1gsRUFBRTFELDRDQUFTQTtBQUVYLGlFQUFlMEQsY0FBY0EsRUFBQyxDQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbmZpbml0ZS1zY3JvbGwtY29tcG9uZW50L2Rpc3QvaW5kZXguZXMuanM/YWJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQsbm8tcGFyYW0tcmVhc3NpZ24sbm8tc2hhZG93ICovXG5cbi8qKlxuICogVGhyb3R0bGUgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIEVzcGVjaWFsbHkgdXNlZnVsIGZvciByYXRlIGxpbWl0aW5nXG4gKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgICBkZWxheSAgICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW25vVHJhaWxpbmddICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub1RyYWlsaW5nIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgb25seSBleGVjdXRlIGV2ZXJ5IGBkZWxheWAgbWlsbGlzZWNvbmRzIHdoaWxlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uZSBmaW5hbCB0aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IHRocm90dGxlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFtkZWJvdW5jZU1vZGVdIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gIEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIG5vVHJhaWxpbmcsIGNhbGxiYWNrLCBkZWJvdW5jZU1vZGUpIHtcbiAgLypcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAqIGRlYm91bmNlIG1vZGVzLlxuICAgKi9cbiAgdmFyIHRpbWVvdXRJRDtcbiAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG5cbiAgdmFyIGxhc3RFeGVjID0gMDsgLy8gRnVuY3Rpb24gdG8gY2xlYXIgZXhpc3RpbmcgdGltZW91dFxuXG4gIGZ1bmN0aW9uIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aW1lb3V0SUQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgIH1cbiAgfSAvLyBGdW5jdGlvbiB0byBjYW5jZWwgbmV4dCBleGVjXG5cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2xlYXJFeGlzdGluZ1RpbWVvdXQoKTtcbiAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICB9IC8vIGBub1RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cblxuXG4gIGlmICh0eXBlb2Ygbm9UcmFpbGluZyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZGVib3VuY2VNb2RlID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBub1RyYWlsaW5nO1xuICAgIG5vVHJhaWxpbmcgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLypcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuICAgKiBpcyBleGVjdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWxhcHNlZCA9IERhdGUubm93KCkgLSBsYXN0RXhlYztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEV4ZWN1dGUgYGNhbGxiYWNrYCBhbmQgdXBkYXRlIHRoZSBgbGFzdEV4ZWNgIHRpbWVzdGFtcC5cblxuXG4gICAgZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSB0aGlzIGlzIHVzZWQgdG8gY2xlYXIgdGhlIGZsYWdcbiAgICAgKiB0byBhbGxvdyBmdXR1cmUgYGNhbGxiYWNrYCBleGVjdXRpb25zLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRpbWVvdXRJRCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcbiAgICAgIC8qXG4gICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgLlxuICAgICAgICovXG4gICAgICBleGVjKCk7XG4gICAgfVxuXG4gICAgY2xlYXJFeGlzdGluZ1RpbWVvdXQoKTtcblxuICAgIGlmIChkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCAmJiBlbGFwc2VkID4gZGVsYXkpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcbiAgICAgICAqIGBjYWxsYmFja2AuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXG4gICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICovXG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxudmFyIFRocmVzaG9sZFVuaXRzID0ge1xyXG4gICAgUGl4ZWw6ICdQaXhlbCcsXHJcbiAgICBQZXJjZW50OiAnUGVyY2VudCcsXHJcbn07XHJcbnZhciBkZWZhdWx0VGhyZXNob2xkID0ge1xyXG4gICAgdW5pdDogVGhyZXNob2xkVW5pdHMuUGVyY2VudCxcclxuICAgIHZhbHVlOiAwLjgsXHJcbn07XHJcbmZ1bmN0aW9uIHBhcnNlVGhyZXNob2xkKHNjcm9sbFRocmVzaG9sZCkge1xyXG4gICAgaWYgKHR5cGVvZiBzY3JvbGxUaHJlc2hvbGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdW5pdDogVGhyZXNob2xkVW5pdHMuUGVyY2VudCxcclxuICAgICAgICAgICAgdmFsdWU6IHNjcm9sbFRocmVzaG9sZCAqIDEwMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzY3JvbGxUaHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbFRocmVzaG9sZC5tYXRjaCgvXihcXGQqKFxcLlxcZCspPylweCQvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5pdDogVGhyZXNob2xkVW5pdHMuUGl4ZWwsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChzY3JvbGxUaHJlc2hvbGQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2Nyb2xsVGhyZXNob2xkLm1hdGNoKC9eKFxcZCooXFwuXFxkKyk/KSUkLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuaXQ6IFRocmVzaG9sZFVuaXRzLlBlcmNlbnQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChzY3JvbGxUaHJlc2hvbGQpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLndhcm4oJ3Njcm9sbFRocmVzaG9sZCBmb3JtYXQgaXMgaW52YWxpZC4gVmFsaWQgZm9ybWF0czogXCIxMjBweFwiLCBcIjUwJVwiLi4uJyk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUaHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLndhcm4oJ3Njcm9sbFRocmVzaG9sZCBzaG91bGQgYmUgc3RyaW5nIG9yIG51bWJlcicpO1xyXG4gICAgcmV0dXJuIGRlZmF1bHRUaHJlc2hvbGQ7XHJcbn1cblxudmFyIEluZmluaXRlU2Nyb2xsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEluZmluaXRlU2Nyb2xsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW5maW5pdGVTY3JvbGwocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcclxuICAgICAgICBfdGhpcy5hY3Rpb25UcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyB2YXJpYWJsZXMgdG8ga2VlcCB0cmFjayBvZiBwdWxsIGRvd24gYmVoYXZpb3VyXHJcbiAgICAgICAgX3RoaXMuc3RhcnRZID0gMDtcclxuICAgICAgICBfdGhpcy5jdXJyZW50WSA9IDA7XHJcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyB3aWxsIGJlIHBvcHVsYXRlZCBpbiBjb21wb25lbnREaWRNb3VudFxyXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgZG93biBlbGVtZW50XHJcbiAgICAgICAgX3RoaXMubWF4UHVsbERvd25EaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgX3RoaXMuZ2V0U2Nyb2xsYWJsZVRhcmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNjcm9sbGFibGVUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5zY3JvbGxhYmxlVGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLnNjcm9sbGFibGVUYXJnZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMucHJvcHMuc2Nyb2xsYWJsZVRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNjcm9sbGFibGVUYXJnZXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdSBhcmUgdHJ5aW5nIHRvIHBhc3Mgc2Nyb2xsYWJsZVRhcmdldCBidXQgaXQgaXMgbnVsbC4gVGhpcyBtaWdodFxcbiAgICAgICAgaGFwcGVuIGJlY2F1c2UgdGhlIGVsZW1lbnQgbWF5IG5vdCBoYXZlIGJlZW4gYWRkZWQgdG8gRE9NIHlldC5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5rZWV0bWFpbmkvcmVhY3QtaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudC9pc3N1ZXMvNTkgZm9yIG1vcmUgaW5mby5cXG4gICAgICBcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5vblN0YXJ0ID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMubGFzdFNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRZID0gZXZ0LnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0WSA9IGV2dC50b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRZID0gX3RoaXMuc3RhcnRZO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX2luZlNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLnRyYW5zaXRpb24gPSBcInRyYW5zZm9ybSAwLjJzIGN1YmljLWJlemllcigwLDAsMC4zMSwxKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5vbk1vdmUgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuZHJhZ2dpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50WSA9IGV2dC5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50WSA9IGV2dC50b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVzZXIgaXMgc2Nyb2xsaW5nIGRvd24gdG8gdXBcclxuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnRZIDwgX3RoaXMuc3RhcnRZKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFkgLSBfdGhpcy5zdGFydFkgPj1cclxuICAgICAgICAgICAgICAgIE51bWJlcihfdGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaFRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBwdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzbyB5b3UgY2FuIGRyYWcgdXB0byAxLjUgdGltZXMgb2YgdGhlIG1heFB1bGxEb3duRGlzdGFuY2VcclxuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnRZIC0gX3RoaXMuc3RhcnRZID4gX3RoaXMubWF4UHVsbERvd25EaXN0YW5jZSAqIDEuNSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9pbmZTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlM2QoMHB4LCBcIiArIChfdGhpcy5jdXJyZW50WSAtXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRZKSArIFwicHgsIDBweClcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMub25FbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0WSA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRZID0gMDtcclxuICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMucmVmcmVzaEZ1bmN0aW9uICYmIF90aGlzLnByb3BzLnJlZnJlc2hGdW5jdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5faW5mU2Nyb2xsXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2luZlNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS53aWxsQ2hhbmdlID0gJ3Vuc2V0JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5vblNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMucHJvcHMub25TY3JvbGwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhpcyBjYWxsYmFjayBpbiBuZXh0IHRpY2sgc28gdGhhdCBpdCBkb2VzIG5vdCBhZmZlY3QgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbmFsaXR5IG9mIHRoZSBsaWJyYXJ5LlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm9wcy5vblNjcm9sbCAmJiBfdGhpcy5wcm9wcy5vblNjcm9sbChldmVudCk7IH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfdGhpcy5wcm9wcy5oZWlnaHQgfHwgX3RoaXMuX3Njcm9sbGFibGVOb2RlXHJcbiAgICAgICAgICAgICAgICA/IGV2ZW50LnRhcmdldFxyXG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSBpZiB0aGUgYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLFxyXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSB0cmlnZ2Vycy5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmFjdGlvblRyaWdnZXJlZClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGF0Qm90dG9tID0gX3RoaXMucHJvcHMuaW52ZXJzZVxyXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5pc0VsZW1lbnRBdFRvcCh0YXJnZXQsIF90aGlzLnByb3BzLnNjcm9sbFRocmVzaG9sZClcclxuICAgICAgICAgICAgICAgIDogX3RoaXMuaXNFbGVtZW50QXRCb3R0b20odGFyZ2V0LCBfdGhpcy5wcm9wcy5zY3JvbGxUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBgbmV4dGAgZnVuY3Rpb24gaW4gdGhlIHByb3BzIHRvIHRyaWdnZXIgdGhlIG5leHQgZGF0YSBmZXRjaFxyXG4gICAgICAgICAgICBpZiAoYXRCb3R0b20gJiYgX3RoaXMucHJvcHMuaGFzTW9yZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9uVHJpZ2dlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvd0xvYWRlcjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm5leHQgJiYgX3RoaXMucHJvcHMubmV4dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmxhc3RTY3JvbGxUb3AgPSB0YXJnZXQuc2Nyb2xsVG9wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHNob3dMb2FkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBwdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBwcmV2RGF0YUxlbmd0aDogcHJvcHMuZGF0YUxlbmd0aCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnRocm90dGxlZE9uU2Nyb2xsTGlzdGVuZXIgPSB0aHJvdHRsZSgxNTAsIF90aGlzLm9uU2Nyb2xsTGlzdGVuZXIpLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uU3RhcnQgPSBfdGhpcy5vblN0YXJ0LmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIF90aGlzLm9uTW92ZSA9IF90aGlzLm9uTW92ZS5iaW5kKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5vbkVuZCA9IF90aGlzLm9uRW5kLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuZGF0YUxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFuZGF0b3J5IHByb3AgXFxcImRhdGFMZW5ndGhcXFwiIGlzIG1pc3NpbmcuIFRoZSBwcm9wIGlzIG5lZWRlZFwiICtcclxuICAgICAgICAgICAgICAgIFwiIHdoZW4gbG9hZGluZyBtb3JlIGNvbnRlbnQuIENoZWNrIFJFQURNRS5tZCBmb3IgdXNhZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVOb2RlID0gdGhpcy5nZXRTY3JvbGxhYmxlVGFyZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMucHJvcHMuaGVpZ2h0XHJcbiAgICAgICAgICAgID8gdGhpcy5faW5mU2Nyb2xsXHJcbiAgICAgICAgICAgIDogdGhpcy5fc2Nyb2xsYWJsZU5vZGUgfHwgd2luZG93O1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpc1xyXG4gICAgICAgICAgICAgICAgLnRocm90dGxlZE9uU2Nyb2xsTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuaW5pdGlhbFNjcm9sbFkgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHRoaXMuZWwgJiZcclxuICAgICAgICAgICAgdGhpcy5lbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsWSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnNjcm9sbFRvKDAsIHRoaXMucHJvcHMuaW5pdGlhbFNjcm9sbFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaCAmJiB0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25TdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vbkVuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblN0YXJ0KTtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25FbmQpO1xyXG4gICAgICAgICAgICAvLyBnZXQgQkNSIG9mIHB1bGxEb3duIGVsZW1lbnQgdG8gcG9zaXRpb24gaXQgYWJvdmVcclxuICAgICAgICAgICAgdGhpcy5tYXhQdWxsRG93bkRpc3RhbmNlID1cclxuICAgICAgICAgICAgICAgICh0aGlzLl9wdWxsRG93biAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1bGxEb3duLmZpcnN0Q2hpbGQgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdWxsRG93bi5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5oZWlnaHQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMDtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMucmVmcmVzaEZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYW5kYXRvcnkgcHJvcCBcXFwicmVmcmVzaEZ1bmN0aW9uXFxcIiBtaXNzaW5nLlxcbiAgICAgICAgICBQdWxsIERvd24gVG8gUmVmcmVzaCBmdW5jdGlvbmFsaXR5IHdpbGwgbm90IHdvcmtcXG4gICAgICAgICAgYXMgZXhwZWN0ZWQuIENoZWNrIFJFQURNRS5tZCBmb3IgdXNhZ2UnXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNcclxuICAgICAgICAgICAgICAgIC50aHJvdHRsZWRPblNjcm9sbExpc3RlbmVyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2gpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Nb3ZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uRW5kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIHdoZW4gZGF0YUxlbmd0aCBpcyB1bmNoYW5nZWRcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kYXRhTGVuZ3RoID09PSBwcmV2UHJvcHMuZGF0YUxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlIHdoZW4gbmV3IGRhdGEgd2FzIHNlbnQgaW5cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgc2hvd0xvYWRlcjogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGRhdGFMZW5ndGhDaGFuZ2VkID0gbmV4dFByb3BzLmRhdGFMZW5ndGggIT09IHByZXZTdGF0ZS5wcmV2RGF0YUxlbmd0aDtcclxuICAgICAgICAvLyByZXNldCB3aGVuIGRhdGEgY2hhbmdlc1xyXG4gICAgICAgIGlmIChkYXRhTGVuZ3RoQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgcHJldkRhdGFMZW5ndGg6IG5leHRQcm9wcy5kYXRhTGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuaXNFbGVtZW50QXRUb3AgPSBmdW5jdGlvbiAodGFyZ2V0LCBzY3JvbGxUaHJlc2hvbGQpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsVGhyZXNob2xkID09PSB2b2lkIDApIHsgc2Nyb2xsVGhyZXNob2xkID0gMC44OyB9XHJcbiAgICAgICAgdmFyIGNsaWVudEhlaWdodCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSB8fCB0YXJnZXQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICAgICAgICAgICA/IHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHRcclxuICAgICAgICAgICAgOiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIHZhciB0aHJlc2hvbGQgPSBwYXJzZVRocmVzaG9sZChzY3JvbGxUaHJlc2hvbGQpO1xyXG4gICAgICAgIGlmICh0aHJlc2hvbGQudW5pdCA9PT0gVGhyZXNob2xkVW5pdHMuUGl4ZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQuc2Nyb2xsVG9wIDw9XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQudmFsdWUgKyBjbGllbnRIZWlnaHQgLSB0YXJnZXQuc2Nyb2xsSGVpZ2h0ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGFyZ2V0LnNjcm9sbFRvcCA8PVxyXG4gICAgICAgICAgICB0aHJlc2hvbGQudmFsdWUgLyAxMDAgKyBjbGllbnRIZWlnaHQgLSB0YXJnZXQuc2Nyb2xsSGVpZ2h0ICsgMSk7XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmlzRWxlbWVudEF0Qm90dG9tID0gZnVuY3Rpb24gKHRhcmdldCwgc2Nyb2xsVGhyZXNob2xkKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbFRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHNjcm9sbFRocmVzaG9sZCA9IDAuODsgfVxyXG4gICAgICAgIHZhciBjbGllbnRIZWlnaHQgPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgfHwgdGFyZ2V0ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcclxuICAgICAgICAgICAgPyB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0XHJcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgICAgICB2YXIgdGhyZXNob2xkID0gcGFyc2VUaHJlc2hvbGQoc2Nyb2xsVGhyZXNob2xkKTtcclxuICAgICAgICBpZiAodGhyZXNob2xkLnVuaXQgPT09IFRocmVzaG9sZFVuaXRzLlBpeGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGFyZ2V0LnNjcm9sbFRvcCArIGNsaWVudEhlaWdodCA+PSB0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGhyZXNob2xkLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0YXJnZXQuc2Nyb2xsVG9wICsgY2xpZW50SGVpZ2h0ID49XHJcbiAgICAgICAgICAgICh0aHJlc2hvbGQudmFsdWUgLyAxMDApICogdGFyZ2V0LnNjcm9sbEhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IF9fYXNzaWduKHsgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodCB8fCAnYXV0bycsIG92ZXJmbG93OiAnYXV0bycsIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnIH0sIHRoaXMucHJvcHMuc3R5bGUpO1xyXG4gICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IHRoaXMucHJvcHMuaGFzQ2hpbGRyZW4gfHxcclxuICAgICAgICAgICAgISEodGhpcy5wcm9wcy5jaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5ICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gYmVjYXVzZSBoZWlnaHRlZCBpbmZpbml0ZVNjcm9sbCB2aXN1YWx5IGJyZWFrc1xyXG4gICAgICAgIC8vIG9uIGRyYWcgZG93biBhcyBvdmVyZmxvdyBiZWNvbWVzIHZpc2libGVcclxuICAgICAgICB2YXIgb3V0ZXJEaXZTdHlsZSA9IHRoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2ggJiYgdGhpcy5wcm9wcy5oZWlnaHRcclxuICAgICAgICAgICAgPyB7IG92ZXJmbG93OiAnYXV0bycgfVxyXG4gICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBvdXRlckRpdlN0eWxlLCBjbGFzc05hbWU6IFwiaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudF9fb3V0ZXJkaXZcIiB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImluZmluaXRlLXNjcm9sbC1jb21wb25lbnQgXCIgKyAodGhpcy5wcm9wcy5jbGFzc05hbWUgfHwgJycpLCByZWY6IGZ1bmN0aW9uIChpbmZTY3JvbGwpIHsgcmV0dXJuIChfdGhpcy5faW5mU2Nyb2xsID0gaW5mU2Nyb2xsKTsgfSwgc3R5bGU6IHN0eWxlIH0sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSwgcmVmOiBmdW5jdGlvbiAocHVsbERvd24pIHsgcmV0dXJuIChfdGhpcy5fcHVsbERvd24gPSBwdWxsRG93bik7IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAtMSAqIHRoaXMubWF4UHVsbERvd25EaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCB0aGlzLnN0YXRlLnB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucHJvcHMucmVsZWFzZVRvUmVmcmVzaENvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoQ29udGVudCkpKSxcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5zaG93TG9hZGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWhhc0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5oYXNNb3JlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5sb2FkZXIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNob3dMb2FkZXIgJiYgdGhpcy5wcm9wcy5oYXNNb3JlICYmIHRoaXMucHJvcHMubG9hZGVyLFxyXG4gICAgICAgICAgICAgICAgIXRoaXMucHJvcHMuaGFzTW9yZSAmJiB0aGlzLnByb3BzLmVuZE1lc3NhZ2UpKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluZmluaXRlU2Nyb2xsO1xyXG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBJbmZpbml0ZVNjcm9sbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ29tcG9uZW50IiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXh0ZW5kcyIsIl9fIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjYWxsIiwiYXBwbHkiLCJ0aHJvdHRsZSIsImRlbGF5Iiwibm9UcmFpbGluZyIsImNhbGxiYWNrIiwiZGVib3VuY2VNb2RlIiwidGltZW91dElEIiwiY2FuY2VsbGVkIiwibGFzdEV4ZWMiLCJjbGVhckV4aXN0aW5nVGltZW91dCIsImNsZWFyVGltZW91dCIsImNhbmNlbCIsInVuZGVmaW5lZCIsIndyYXBwZXIiLCJzZWxmIiwiZWxhcHNlZCIsIkRhdGUiLCJub3ciLCJhcmdzIiwiZXhlYyIsImNsZWFyIiwic2V0VGltZW91dCIsIlRocmVzaG9sZFVuaXRzIiwiUGl4ZWwiLCJQZXJjZW50IiwiZGVmYXVsdFRocmVzaG9sZCIsInVuaXQiLCJ2YWx1ZSIsInBhcnNlVGhyZXNob2xkIiwic2Nyb2xsVGhyZXNob2xkIiwibWF0Y2giLCJwYXJzZUZsb2F0IiwiY29uc29sZSIsIndhcm4iLCJJbmZpbml0ZVNjcm9sbCIsIl9zdXBlciIsInByb3BzIiwiX3RoaXMiLCJsYXN0U2Nyb2xsVG9wIiwiYWN0aW9uVHJpZ2dlcmVkIiwic3RhcnRZIiwiY3VycmVudFkiLCJkcmFnZ2luZyIsIm1heFB1bGxEb3duRGlzdGFuY2UiLCJnZXRTY3JvbGxhYmxlVGFyZ2V0Iiwic2Nyb2xsYWJsZVRhcmdldCIsIkhUTUxFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm9uU3RhcnQiLCJldnQiLCJNb3VzZUV2ZW50IiwicGFnZVkiLCJUb3VjaEV2ZW50IiwidG91Y2hlcyIsIl9pbmZTY3JvbGwiLCJzdHlsZSIsIndpbGxDaGFuZ2UiLCJ0cmFuc2l0aW9uIiwib25Nb3ZlIiwiTnVtYmVyIiwicHVsbERvd25Ub1JlZnJlc2hUaHJlc2hvbGQiLCJzZXRTdGF0ZSIsInB1bGxUb1JlZnJlc2hUaHJlc2hvbGRCcmVhY2hlZCIsIm92ZXJmbG93IiwidHJhbnNmb3JtIiwib25FbmQiLCJzdGF0ZSIsInJlZnJlc2hGdW5jdGlvbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9uU2Nyb2xsTGlzdGVuZXIiLCJldmVudCIsIm9uU2Nyb2xsIiwidGFyZ2V0IiwiaGVpZ2h0IiwiX3Njcm9sbGFibGVOb2RlIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwiYm9keSIsImF0Qm90dG9tIiwiaW52ZXJzZSIsImlzRWxlbWVudEF0VG9wIiwiaXNFbGVtZW50QXRCb3R0b20iLCJoYXNNb3JlIiwic2hvd0xvYWRlciIsIm5leHQiLCJwcmV2RGF0YUxlbmd0aCIsImRhdGFMZW5ndGgiLCJ0aHJvdHRsZWRPblNjcm9sbExpc3RlbmVyIiwiYmluZCIsImNvbXBvbmVudERpZE1vdW50IiwiRXJyb3IiLCJlbCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0aWFsU2Nyb2xsWSIsInNjcm9sbEhlaWdodCIsInNjcm9sbFRvIiwicHVsbERvd25Ub1JlZnJlc2giLCJfcHVsbERvd24iLCJmaXJzdENoaWxkIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZm9yY2VVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJkYXRhTGVuZ3RoQ2hhbmdlZCIsImNsaWVudEhlaWdodCIsInNjcmVlbiIsImF2YWlsSGVpZ2h0IiwidGhyZXNob2xkIiwicmVuZGVyIiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJoYXNDaGlsZHJlbiIsImNoaWxkcmVuIiwib3V0ZXJEaXZTdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJyZWYiLCJpbmZTY3JvbGwiLCJwb3NpdGlvbiIsInB1bGxEb3duIiwibGVmdCIsInJpZ2h0IiwidG9wIiwicmVsZWFzZVRvUmVmcmVzaENvbnRlbnQiLCJwdWxsRG93blRvUmVmcmVzaENvbnRlbnQiLCJsb2FkZXIiLCJlbmRNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js\n");

/***/ })

};
;